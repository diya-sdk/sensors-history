<link rel="import" href="../polymer/polymer.html">

<script type="text/javascript" src="../d3/d3.min.js"></script>


<polymer-element name="sensors-history" attributes="period selector sensors relTime timeBeg timeEnd timeRange sampling">
	<template>
	<style>
		:host {
			display: flex;
			flex-direction: horizontal;
			justify-content: center;
			/*width: 100vw;*/
		}
		.axis path,
		.axis line {
			fill: none;
			stroke: #000;
			shape-rendering: crispEdges;
			stroke-width: 3px;
		}
		.line {
			fill: none;
			stroke: steelblue;
			stroke-width: 3px;
		}
		text {
			font-size: 18px;
			font-weight: bold;
		}

		svg {
			width: 100%;
			height: 100%;
		}
	</style>

	<!-- <span class="chart"> -->
		<svg id="chart" viewBox="0 0 {{viewBoxWidth}} {{viewBoxHeight}}" preserveAspectRatio="xMinYMin meet"></svg>
	<!-- </span> -->

	</template>

	<script>
	function linesChart(element, width, height,_relTime) {
		var data = [];
		var that = {};
		var margin = {
			top: 10,
			right: 20,
			bottom: 60,
			left: 22,
			legendWidth: 250,
			legendTopMargin: 80,
			dyLegend: 30
		};
		var h = height - margin.top - margin.bottom,
		w = width - margin.left - margin.right,
		x, y, yArray={};
		that.relTime = _relTime;

		var xLegend = width / 2 - margin.legendWidth - margin.right - margin.left;
		var wLegend = margin.legendWidth;
		var yLegend = margin.legendTopMargin;
		var dyLegend = margin.dyLegend;

		var relTimeFormat = d3.time.format.multi([
			[".%L", function(d) { return d.getUTCMilliseconds(); }],
			[":%S", function(d) { return d.getUTCSeconds(); }],
			["%M:00", function(d) { return d.getUTCMinutes(); }],
			["%H ", function(d) { return d.getUTCHours(); }],
			["%x", function(d) { return true }]
		]);
		var absTimeFormat = d3.time.format.multi([
			[".%L", function(d) { return d.getMilliseconds(); }],
			[":%S", function(d) { return d.getSeconds(); }],
			["%H:%M", function(d) { return d.getMinutes(); }],
			["%H:00", function(d) { return d.getHours(); }],
			["%d/%m", function(d) { return true }]
		]);
		
		/* create svg. Should define dimensions too */
		var svg = d3.select(element)
		//~ .attr("width", width + margin.left + margin.right)
		//~ .attr("height", height + margin.top + margin.bottom)
			.append('g')
			.attr("transform", "translate(" + margin.left + ", " + margin.top + ")");

		// default attr for axis
		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + h + ")");
		svg.append("g")
			.attr("class", "y axis");

		// create legend box
		svg.append("g")
			.attr("class", "legend")
			.attr("transform", "translate(" + xLegend + ", " + yLegend + ")");



		/* definition couleurs - 10 categories de couleurs differentes */
		var color = d3.scale.category10();

		/* default graphical binding for chart axis */
		// x = d3.scale.linear().range([0, w]);

		if(that.relTime) {
			x = d3.time.scale.utc().range([0, w]); /* display scale UTC */
		}
		else {
			x = d3.time.scale().range([0, w]);
		}


		//~ /* fonction pour parsing des date - choix format d'affichage des dates */
		/* var timeFormat = d3.time.format("%H:%M:%S"); */

		/* line generator */
		that.line = d3.svg.line()
			.x(function(d) { return x(d.t); })
			.interpolate('basis');

		/** render display */
		that.render = function(model,trange) {
			if (!model) return;

			//~ console.log(JSON.stringify(model));

			/* define association between keys and colors */
			color.domain(d3.keys(model).filter(function(name) { return name !== "time"; }));

			/* renvoie nom, values */
			var sensorData = color.domain().map(function(name) {
				return {
					name: name,
					label: model[name].label,
					unit: model[name].unit,
					trange: trange, //d3.extent(model[name].time),
					values: model[name].vals.map(function(d,i) {
						return {t: model[name].time[i], val: d};
					})
				};
			});


			/* [OPTION] reversed because we want to display from present to past */
			if(!trange)
				console.log("ERROR - TRANGE UNDEFINED");


			if(false) {
				x.domain(trange.reverse());
				console.log("reverse");
			}
			else {
				x.domain(trange);
				//console.log("notReverse");
			}

			/** extract scale for each data */
			for(var i in model) {
				if(i != 'time') {
					yArray[i]=d3.scale.linear().range([h, 0]).domain(model[i].range);
				}
			}

			xAxis = d3.svg.axis()
				.scale(x)
			    .ticks(6)
				.orient("bottom");

			/* set specific format for rel or abs time */
			if(this.relTime) {
				xAxis.tickFormat(relTimeFormat)
			}
			else {
				xAxis.tickFormat(absTimeFormat);
			}

			this.updateLegend(sensorData);
			this.updateLines(sensorData);
			this.updateAxis();
		};

		that.updateLegend = function(data) {
			var that=this;

			var sensorLegend = svg.select(".legend").selectAll(".sensorLegend")
				.data(data);
			sensorLegend.exit()
				.remove();
			var gSensorLegend = sensorLegend.enter().append("g")
				.attr("class", "sensorLegend");

			gSensorLegend.append("text")
				.attr("class", "sensorName")
				.attr("dy", ".35em")
				.style("fill", function(d) { return color(d.name); })

			gSensorLegend.append("text")
				.attr("class", "sensorValue")
				.attr("dy", ".35em")
				.style("fill", function(d) { return color(d.name); })

			svg.selectAll(".sensorLegend").select(".sensorName")
				.datum(function(d) { return {name: d.name, label: d.label }})
				.attr("transform", function(d, i) { return "translate(" + 0 + "," + (i*dyLegend) + ")"; })
				.text(function(d) { return d.label; }); /* text */

			svg.selectAll(".sensorLegend").select(".sensorValue")
				.datum(function(d) { return {name: d.name, unit: d.unit, value: d.values[0]}; }) // select most recent element
				.attr("transform", function(d, i) { return "translate(" + wLegend + "," + (i*dyLegend) + ")"; })
				.style("text-anchor","end")
				.text(function(d) {
					return (typeof d.value.val != 'undefined' ? d.value.val.toFixed(1)+" "+d.unit : ""); }); /* text */

		}

		that.updateLines = function(data) {
			var that=this;

			var sensorData = svg.selectAll(".sensorData") /* get all info with class city in DOM */
				.data(data); /* join new data cities to previous one */

			/* Update line and text for preexisting elements */
			sensorData.select(".line") /* there should be only one path with class line */
				.attr("d", function(d) {
					that.line.y(function(dy) {
						return yArray[d.name](dy.val);
					}); /* update scale */
					return that.line(d.values); });
			//~ sensorData.select(".text")
			//~ .datum(function(d) { return {name: d.name, value: d.values[d.values.length-1]}; })
			//~ .attr("transform", function(d) { return "translate(" + x(d.value.t) + "," + yArray[d.name](d.value.val) + ")"; })
			//~ .text(function(d) {
			//~ return d.name+" - "+ d.value.val.toFixed(1); }); /* text */
			sensorData.exit()
				.remove();
			sensorData = sensorData.enter().append("g") /* on added data,	add to g element of svg (i.e. graphical elements of svg) */
				.attr("class", "sensorData"); /* and define class 'sensorData' */
			/* add line and text */
			sensorData.append("path")
				.attr("class", "line")
				.attr("d", function(d) {
					that.line.y(function(dy) {
						return yArray[d.name](dy.val);
					}); /* update scale */
					return that.line(d.values); }) /* 'd' instructions to draw line in svg. generated from the 'line' wrapper */
				.style("stroke", function(d) { return color(d.name); }); /* define color according to colormap (10) */
			//~ sensorData.append("text")
			//~ .datum(function(d) { return {name: d.name, value: d.values[d.values.length-1]}; })	/* define how to get data (d in transform function) */
			//~ .attr("transform", function(d) { return "translate(" + x(d.value.t) + "," + yArray[d.name](d.value.val) + ")"; }) /* x and y are wrapper to compute coordinates in frame according to values */
			//~ .attr("class", "text")
			//~ .attr("x", 5) /* position and dim of text area */
			//~ .attr("dy", ".35em")
			//~ .style("fill", function(d) { return color(d.name); })
			//~ .text(function(d) {
			//~ return d.name+" - "+ d.value.val.toFixed(1); }); /* text */
		};

		that.updateAxis = function() {
			svg.selectAll("g.x.axis")
				.call(xAxis) // rotate xAxis ticks
				.selectAll("text")
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", ".15em")
				.attr("transform", function(d) {
					return "rotate(-65)"
				});
		};

		that.clean = function () {
			svg.selectAll("*").remove();
		};

		return that;
	};


	Polymer({
		viewBoxWidth: 640,
		viewBoxHeight: 480,

		ready: function(){
			this.period = this.period || 10000; //10 s
			this.selector = this.selector || null;
			// this.sensors = (this.sensors ? JSON.parse(this.sensors) : null);
			if (typeof this.place === "string")
				this.place = JSON.parse(this.place); // RQ: convert into object here ? Is it possible to exchange data directly after init by JSON ?
			this.robot = this.robot || null;
			this.timeBeg = new Date(this.timeBeg).getTime() || null;
			this.timeEnd = new Date(this.timeEnd).getTime() || null;
			this.timeRange = this.timeRange || null;
			this.sampling = this.sampling || null;
			this.time = {
				beg: this.timeBeg,
				end: this.timeEnd,
				range: this.timeRange	
			};

			this.relTime = this.relTime || false;

			//console.log("xRev: "+this.relTime);
			/* create/init d3 chart */
			this.chart = linesChart(this.$.chart, this.viewBoxWidth, this.viewBoxHeight, this.relTime);
		},

		selectorChanged: function() {
			// autorefresh?
			if (this.period != null) {
				var that=this;
				if (this.interval) {
					clearInterval(this.interval);
				}
				this.interval = setInterval(function() { that.updateChart(null); }, this.period);
			}
		},

		/**
		 *		Update chart
		 */
		updateChart: function () {
			//~ console.log(JSON.stringify(model));
			var sensors = this.sensors.split(',');

			if(this.selector) {
				var that=this;
				//console.log("time : "+JSON.stringify(this.time));

				/* request for data from ieq service */
				var dataConfig = {
					sampling: this.sampling,
					operator: "last",
					criteria: {
						time: this.time,
						place: this.place,
						robot: JSON.parse(this.robot)
					},
					sensors: sensors //['Temperature','Humidity','CO2','VOCt','Fine Dust','Ozone']
				};
				//console.log("Linechart : "+JSON.stringify(dataConfig));
				d1(this.selector).IEQ().updateData(function(model) {
					//console.log(model);
					if(model)
					{
						// bug in Ieq.js, when multiple IEQ instances request db, this.sendModel will be corrupted, might contains more or less sensors data than requested
						// so we do the filter in this code till this bug is fixed
						for (var sensor in model) {
							if (!~sensors.indexOf(sensor)) {
								delete model[sensor];
							}
						}

						var dispModel = {};
						for (m in model) {
							dispModel[m]={};
							if (m !== 'placeId' && m!== 'robotId') {
								if(that.relTime) {
									/** extract relative time */
									dispModel[m].time = model[m].time.map(function(t,i){return that.time.end-t;});
								}
								else {
									dispModel[m].time = model[m].time;
								}
								dispModel[m].vals = model[m].data;
								dispModel[m].range = model[m].range;
								dispModel[m].timeRange = model[m].timeRange;
								dispModel[m].unit = model[m].unit;
								dispModel[m].label = model[m].label;
							}
						}
						
						var tRange = Object.keys(dispModel).reduce(function(tRange,k) {
							if(tRange) {
								return [
									Math.min(dispModel[k].timeRange[0],tRange[0]),
									Math.max(dispModel[k].timeRange[1],tRange[1])
								];
							}
							else 
								return dispModel[k].timeRange;
						}, null);
										   
						if (that.chart != null) {
							that.chart.render(dispModel, tRange);
						}
					}
				}, dataConfig);
			}
			else
				console.log("Selector undefined");
		}
	});
	</script>

</polymer-element>
