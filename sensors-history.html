<link rel="import" href="../polymer/polymer.html">

<script type="text/javascript" src="../d3/d3.min.js"></script>


<polymer-element name="sensors-history" attributes="width height period selector sensors">
	<template>
		<style>
			:host {
				display: flex;
				flex-direction: horizontal;
				justify-content: center;
				width: 100vw;
			}
			.axis path,
			.axis line {
			  fill: none;
			  stroke: #000;
			  shape-rendering: crispEdges;
				stroke-width: 3px;
			}
			.line {
			  fill: none;
			  stroke: steelblue;
				stroke-width: 3px;
			}
      text {
				font-size: 18px;
				font-weight: bold;
			}
		</style>

		<span class="chart">
		 <svg id="chart" width="{{width}}" height="{{height}}"></svg>
		</span>

	</template>

	<script>
		function linesChart(element, width, height,_xReversed) {
			var data = [];
			var that = {};
			var margin = {
				top: 10,
				right: 20,
				bottom: 40,
				left: 20,
				legendWidth: 250,
				legendTopMargin: 150,
				dyLegend: 30
			};
			var h = height - margin.top - margin.bottom,
				w = width - margin.left - 2*margin.right - margin.legendWidth,
				x, y, yArray={};
			var xReversed = _xReversed;

			var xLegend = width - margin.legendWidth - margin.right - margin.left;
			var wLegend = margin.legendWidth;
			var yLegend = margin.legendTopMargin;
			var dyLegend = margin.dyLegend;

			var customTimeFormat = d3.time.format.multi([
				[".%L", function(d) { return d.getUTCMilliseconds(); }],
				[":%S", function(d) { return d.getUTCSeconds(); }],
				["%M:00", function(d) { return d.getUTCMinutes(); }],
				["%H ", function(d) { return d.getUTCHours(); }],
				["00", function(d) { return true }]
			]);

			/* create svg. Should define dimensions too */
			var svg = d3.select(element)
			//~ .attr("width", width + margin.left + margin.right)
			//~ .attr("height", height + margin.top + margin.bottom)
				.append('g')
				.attr("transform", "translate(" + margin.left + ", " + margin.top + ")");

			// default attr for axis
			svg.append("g")
				.attr("class", "x axis")
				.attr("transform", "translate(0," + h + ")");
			svg.append("g")
				.attr("class", "y axis");

			// create legend box
			svg.append("g")
				.attr("class", "legend")
				.attr("transform", "translate(" + xLegend + ", " + yLegend + ")");



			/* definition couleurs - 10 categories de couleurs differentes */
			var color = d3.scale.category10();

			/* default graphical binding for chart axis */
			// x = d3.scale.linear().range([0, w]);
			x = d3.time.scale.utc().range([0, w]); /* OK pour scale */

			//~ /* fonction pour parsing des date - choix format d'affichage des dates */
			var timeFormat = d3.time.format("%H:%M:%S");

			/* line generator */
			that.line = d3.svg.line()
				.x(function(d) { return x(d.t); })
				.interpolate('basis');

			/** render display */
			that.render = function(model) {
				if (!model || !model.time || model.time.length == 0 ) return;

				//~ console.log(JSON.stringify(model));

				/* define association between keys and colors */
				color.domain(d3.keys(model).filter(function(name) { return name !== "time"; }));

				/* renvoie nom, values */
				var sensorData = color.domain().map(function(name) {
					return {
						name: name,
						label: model[name].label,
						unit: model[name].unit,
						values: model[name].data.map(function(d,i) {
							return {t: model.time[i], val: d};
						})
					};
				});


				/* [OPTION] reversed because we want to display from present to past */
				if(xReversed)
					x.domain(d3.extent(model.time).reverse());
				else
					x.domain(d3.extent(model.time));

				/** extract scale for each data */
				for(var i in model) {
					if(i != 'time') {
						yArray[i]=d3.scale.linear().range([h, 0]).domain(model[i].range);
					}
				}

				xAxis = d3.svg.axis()
					.scale(x)
					.tickFormat(customTimeFormat)
					.orient("bottom");

				this.updateLegend(sensorData);
				this.updateLines(sensorData);
				this.updateAxis();
			};

			that.updateLegend = function(data) {
				var that=this;

				var sensorLegend = svg.select(".legend").selectAll(".sensorLegend")
						.data(data);
				sensorLegend.exit()
						.remove();
				var gSensorLegend = sensorLegend.enter().append("g")
						.attr("class", "sensorLegend");
				gSensorLegend.append("text")
						.attr("class", "sensorName")
						.attr("dy", ".35em")
						.style("fill", function(d) { return color(d.name); })
				gSensorLegend.append("text")
						.attr("class", "sensorValue")
						.attr("dy", ".35em")
						.style("fill", function(d) { return color(d.name); })
				svg.selectAll(".sensorLegend").select(".sensorName")
						.datum(function(d) { return {name: d.name, label: d.label }})
						.attr("transform", function(d, i) { return "translate(" + 0 + "," + (i*dyLegend) + ")"; })
						.text(function(d) { return d.label; }); /* text */
				svg.selectAll(".sensorLegend").select(".sensorValue")
						.datum(function(d) { return {name: d.name, unit: d.unit, value: d.values[0]}; }) // select most recent element
						.attr("transform", function(d, i) { return "translate(" + wLegend + "," + (i*dyLegend) + ")"; })
            .style("text-anchor","end")
						.text(function(d) {
							return (typeof d.value.val != 'undefined' ? d.value.val.toFixed(1)+" "+d.unit : ""); }); /* text */

			}

			that.updateLines = function(data) {
				var that=this;

				var sensorData = svg.selectAll(".sensorData") /* get all info with class city in DOM */
						.data(data); /* join new data cities to previous one */

				/* Update line and text for preexisting elements */
				sensorData.select(".line") /* there should be only one path with class line */
						.attr("d", function(d) {
							that.line.y(function(dy) {
									return yArray[d.name](dy.val);
								}); /* update scale */
							return that.line(d.values); });
				//~ sensorData.select(".text")
						//~ .datum(function(d) { return {name: d.name, value: d.values[d.values.length-1]}; })
						//~ .attr("transform", function(d) { return "translate(" + x(d.value.t) + "," + yArray[d.name](d.value.val) + ")"; })
						//~ .text(function(d) {
							//~ return d.name+" - "+ d.value.val.toFixed(1); }); /* text */
				sensorData.exit()
						.remove();
				sensorData = sensorData.enter().append("g") /* on added data,  add to g element of svg (i.e. graphical elements of svg) */
						.attr("class", "sensorData"); /* and define class 'sensorData' */
				/* add line and text */
				sensorData.append("path")
						.attr("class", "line")
						.attr("d", function(d) {
							that.line.y(function(dy) {
									return yArray[d.name](dy.val);
								}); /* update scale */
							return that.line(d.values); }) /* 'd' instructions to draw line in svg. generated from the 'line' wrapper */
						.style("stroke", function(d) { return color(d.name); }); /* define color according to colormap (10) */
				//~ sensorData.append("text")
						//~ .datum(function(d) { return {name: d.name, value: d.values[d.values.length-1]}; })  /* define how to get data (d in transform function) */
						//~ .attr("transform", function(d) { return "translate(" + x(d.value.t) + "," + yArray[d.name](d.value.val) + ")"; }) /* x and y are wrapper to compute coordinates in frame according to values */
						//~ .attr("class", "text")
						//~ .attr("x", 5) /* position and dim of text area */
						//~ .attr("dy", ".35em")
						//~ .style("fill", function(d) { return color(d.name); })
						//~ .text(function(d) {
							//~ return d.name+" - "+ d.value.val.toFixed(1); }); /* text */
			};

			that.updateAxis = function() {
				svg.selectAll("g.x.axis")
					.call(xAxis);
			};

			that.clean = function () {
				svg.selectAll("*").remove();
			};

			return that;
		};


		Polymer({
			ready: function(){
				var that=this;
				this.width =  this.width || 600;
				this.height = this.height || 400;
				this.period = this.period || 10000; //10 s
				this.xReversed = this.xReversed || 400;
				this.selector = this.selector || null;
				this.sensors = this.sensors || null;

				/* create/init d3 chart */
				this.chart = linesChart(this.$.chart, this.width, this.height, this.xReversed);

				setTimeout(function() {that.autorefresh();}, this.period);
			},
			autorefresh: function() {
				var that = this;
				this.updateChart();
				setTimeout(function() {that.autorefresh();}, this.period);
			},
			/**
			*		Update chart
			*/
			updateChart: function (){
				//~ console.log(JSON.stringify(model));
				if(this.selector) {
					var that=this;

					/* request for data from ieq service */
					tend = new Date().getTime();
					tdeb = tend-10*60*1000; // 5 min
					var dataConfig = {
						sampling: 100,
						operator: "last",
						criteria: {
							time: {
								deb: tdeb,
								end: tend
							}
						},
		        sensors: this.sensors
					}
					console.log("Linechart : "+JSON.stringify(dataConfig));
					d1(this.selector).IEQ().updateData(function(model) {
						if(model)
						{
							var dispModel = {};
							for (m in model) {
								if(m === 'time') { /** extract relative time */
									var now = new Date();
									dispModel.time = model.time.data.map(function(t,i) { return now-t;});
								}
								else if (m != 'placeId' && m!== 'robotId')
									dispModel[m] = model[m];
							}
							that.chart.render(dispModel);
						}
					}, dataConfig);
				}
				else
					console.log("Selector undefined");
			}
		});



	</script>

</polymer-element>
